Diary of SunLight project development
=====================================

--------------
Day 1 - Jul 07
--------------

I wanted to use Google maps data to predict the time of sunlight in different apartments near highrises.

--------------
Day 2 - Jul 08
--------------

Google doesn't share height data of buildings, only ground elevation.
[https://developers.google.com/maps/documentation/elevation/]

I found OpenStreetMap data, which has building height data.
[http://wiki.openstreetmap.org/wiki/Main_Page]

Manhattan is fully char

Andrew suggested a health oriented selling point. People who need sunlight due to psychological reasons can check how much sunlight they will get in their apartment/office throughout the day and year before even visiting the place.

I found the Overpass API
[http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide]

--------------
Day 3 - Jul 09
--------------

I found a working call to Overpass API, that downloads an XML.
[http://inasafe.org/en/developer-docs/osm_building_downloads.html]
>>> http://overpass-api.de/api/interpreter?data=(node["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725);way["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725);relation["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725););(._;>;);out body;

I found a simple way to debug the Overpass API calls through Overpass's interactive web app.
[http://overpass-turbo.eu/]

I realized, I need only the "way" objects.

I realized that I need to extend from '["building" = "yes"]'' to simply '["building"]' in the query, since some buildings are e.g. "building" = "church" etc.

I used Google Maps to find an approximate bounding box for Manhattan.
s = 40.685816
w = -74.037724
n = 40.881304
e = -73.902455

I synthetsized the above into the following Overpass API query:
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.685816,-74.037724,40.881304,-73.902455););(._;>;);out body;


Using the above query I downloaded the XML data to 
~/InsightFellowship/Project/Manhattan_buildings.xml

I decidede to use beautifulsoup to parse the XML file. But I don't know in which format should I store the data to make it easy to analyze for light-ray-crossing.


In order to efficiently determine the siluettes of the buildings from the observer's position I'll do the following:
 a. Group the buildings into larger rectangular blocks (N_blocks := sqrt(N_buildings))
 b. For each block calculate and store:
 	i. max height
 	ii. 2D coordinates of the 4 vertices of the block
 c. When rendering the siluette:
 	0. Exlude all blocks with max height smaller than observer's altitude
 	1. Start with self
 	2. Continue with the buildings in the same block
 	3. Continue with the buildings in the neighboring blocks
 	4. Continue with all remaining buildings
 	5. After each a building's siluette is added to the view, exclude blocks that are completely shadowed by the new siluette

I think the above algorithm will allow a fast and complete generation of the siluette view. After which calculating when is the Sun blocked is probably simple.

Given the blocks (4 vertices: x1,y1,x2,y2,x3,y3,x4,y4, and max height z_max), the following pseudocode will (hopefully) do the job:

draw_siluette(buildings, blocks, obs):
	% buildings is an array of building instances:
	%	Key: id
	%	- vertices: array of tuples(x,y)
	%	- height: z
	%	- block id

	% blocks is dict of block instances:
	%	Key: id
	%	- list_of_buildings: array of building id's
	%	- max height, z_max
	%	- vertices: array of length 4 of tuples(x,y)
	% 	- center

	% obs is the observer's position: tuple(x,y,z)

	% siluette is an array of arrays of tuples(phi, theta), ordered by distance from observer, defining the rooflines of the buildings with visible roofline

	siluette = []
	
	block_order = []
	for block in blocks:
		% get blocks which are higher than the observer
		if block.z_max > obs.z:
			% find distances to each block center
			block_order.append( tuple( id, distance(block.center, obs) ) )
	% determine the order in which the blocks should be investigated
	block_order.sort(by second element of the tuple)

	while len(block_order):
		block_id = block_order[0][0]
		% get buildings from the block shorter than the observer
		building_order = []
		for building_id in blocks[block_id.list_of_buildings
			if building.z > obs.z:
				building_order.append(building_id)

		% draw buidlings on siluette
		for building_id in building_order:
			building = buildings(building_id)
			% calculate observing angles for each vertex
			observed_vetices = []
			for vertex in building.vertices:
				tuple = get_phi_theta(vertex, building.z,  obs)
				observed_vertices.append(tuple)				
			siluette.append(observed_vertices)

		% remove the processed block from the list
		block_order.pop(0)

		% evaluate whether the remaining blocks are shadowed
		for remaining_block in block_order:
			block_id = remaining_block[0]
			if is_block_shadowed(block(block_id), siluette):
				block_order.remove(remaining_block)

	% at this point siluette is an array of arrays of tuples(phi, theta), each corresponding to the arrays of the vertices of each buildings from visible blocks

	% let's get rid of totally blocked buildings


		
For the slides for Friday, I decided to plot the histogram of the heights. This seems the easiest, since I need to extract only the height information from the XML file, which is always at '<tag k="height" v="19.6"/>'.

After plotting the histogram, I realized that the landmark buildings are missing their heights. This is because their height is a tag to ways with "building:part" tags.

I tried the following two calls
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.751194, -73.976618, 40.752031, -73.974204););(._;>;);out body;
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.748134, -73.986997, 40.749085, -73.984336););(._;>;);out body;

And tried
"
way["building"](40.748134, -73.986997, 40.749085, -73.984336);
way["building:part"](40.748134, -73.986997, 40.749085, -73.984336);
/*added by auto repair*/
(._;>;);
/*end of auto repair*/
out body;
"
in 
http://overpass-turbo.eu/

This resulted in the full structure data of the Empire State Building. 

So I changed the Overpass API call to
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.685816,-74.037724,40.881304,-73.902455);way["building:part"](40.685816,-74.037724,40.881304,-73.902455););(._;>;);out body;

Empire State Building:
http://overpass-api.de/api/interpreter?data=(way["building"](40.748134, -73.986997, 40.749085, -73.984336);way["building:part"](40.748134, -73.986997, 40.749085, -73.984336););(._;>;);out body;


--------------
Day 4 - Jul 10
--------------

In the morning I put together the slides, "3Slides.pdf" for the afternoon presentation.

Before starting crunching the data, I need to parse the XML into a structure I can use.
XML contains the following type of lines:
Header lines:
	<?xml version="1.0" encoding="UTF-8"?>
	<osm version="0.6" generator="Overpass API">
	<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>
	<meta osm_base="2015-07-10T01:22:02Z"/>

Node list:
  	<node id="530737132" lat="40.7514887" lon="-73.9758501"/>
	  OR
    <node id="2666720512" lat="40.7522067" lon="-73.9741698">
	<tag k="entrance" v="main"/>
	</node>

Way definitions:
	<way id="42500770">
	    <nd ref="530737132"/>
	    <nd ref="2665014478"/>
	    <nd ref="2665014638"/>
	    <nd ref="530737135"/>
	    <nd ref="530737137"/>
	    <nd ref="2665014479"/>
	    <nd ref="2665014429"/>
	    <nd ref="2714805423"/>
	    <nd ref="2665014352"/>
	    <nd ref="2665014344"/>
	    <nd ref="2665014314"/>
	    <nd ref="2665014313"/>
	    <nd ref="2714805412"/>
	    <nd ref="530737139"/>
	    <nd ref="530737132"/>
	    <tag k="building" v="tower"/>
	    <tag k="building:part" v="no"/>
	    <tag k="building:use" v="office"/>
	    <tag k="name" v="Chrysler Building"/>
	    <tag k="name:el" v="Κτίριο Κράισλερ"/>
	    <tag k="name:es" v="Edificio Chrysler"/>
	    <tag k="name:he" v="בניין קרייזלר"/>
	    <tag k="name:ru" v="Крайслер-билдинг"/>
	    <tag k="start_date" v="1930"/>
	    <tag k="tourism" v="yes"/>
	    <tag k="wikipedia" v="en:Chrysler Building"/>
  	</way>
  		OR
  	<way id="159899676">
	    <nd ref="1719705334"/>
	    <nd ref="1719705331"/>
	    <nd ref="1719705315"/>
	    <nd ref="1719705327"/>
	    <nd ref="1719705334"/>
	    <tag k="building" v="yes"/>
	    <tag k="building:colour" v="#818880"/>
	    <tag k="building:part" v="yes"/>
	    <tag k="height" v="22"/>
	    <tag k="name" v="Socony-Mobil Building"/>
	    <tag k="nycdoitt:bin" v="1036153"/>
	    <tag k="roof:material" v="concrete"/>
	    <tag k="roof:shape" v="flat"/>
	    <tag k="start_date" v="1956"/>
  	</way>

Footer:
	</osm>

In 'Crysler.xml', I have a small dataset, containing the entire Crysler buidling, which I'll use to debug my code.

Tasks for today:
1. Load list of nodes and ways into pandas dataframes
2. Create a new dataframe, containing building data
3. Save the building dataframe to disk
4. Determine good coordinates to define the blocks
5. Create the blocks in a new dataframe
6. Save the blocks dataframe to the disk


Here's a piece of Python code to check which packages are installed:
>>> import pip
>>> installed_packages = pip.get_installed_distributions()
>>> installed_packages_list = sorted(["%s==%s" % (i.key, i.version)
     for i in installed_packages])
>>> print(installed_packages_list)


--------------
Day 5 - Jul 12
--------------

Tasks for today:
--OK-- 1. Load list of nodes and ways into dicts
--OK-- 2. Create a new dict, containing building data
3. Save the building data to disk
4. Determine good coordinates to define the blocks
5. Create the blocks in a new dict
6. Save the blocks dict to the disk


I defined the center attribute to the Building class, and this way I created a scatter plot of all buildings in the dataset. Since the bounding box for the Overpass API was a rectangle, many more buidlings are included, other than the ones in Manhattan.

I need a way to select the buildings in Manhattan.

Let's list the coordinates of Mahnattan's (approximate boundary).
40.686467, -74.034462
40.700003, -74.025536
40.756201, -74.013176
40.826122, -73.964768
40.881953, -73.933525
40.871569, -73.909150
40.856900, -73.919707
40.845149, -73.928547
40.835733, -73.933096
40.807869, -73.931637
40.790975, -73.910523
40.777198, -73.928032
40.779278, -73.934813
40.773623, -73.939190
40.768488, -73.939791
40.739945, -73.966399
40.709633, -73.971978
40.703842, -73.998328
40.680804, -74.021073

I need an algorithm to drop to buildings that our outside this boundary.

I can do this if the boundary is convex. Let's define a convex boundary:
40.875615, -73.904533
40.791452, -73.907966
40.706402, -73.967017
40.676465, -74.020233
40.682193, -74.035339
40.757133, -74.015083
40.884441, -73.932342

This worked okay. I can refine the results by defining the convex boundaries of the neighboring regions:
Bronx:
40.871332, -73.909511
40.894563, -73.880328
40.852377, -73.811836
40.803538, -73.822307
40.795871, -73.911914
40.802563, -73.927836
40.809515, -73.933501
40.824422, -73.933415
40.835203, -73.933973
40.847118, -73.927364
40.861531, -73.916334

This worked nicely. Now, let's do the same for Brooklyn:
40.708105, -73.974007
40.744920, -73.961819
40.755974, -73.952034
40.778206, -73.931606
40.791463, -73.910149
40.801340, -73.885430
40.752983, -73.788269
40.653038, -73.900192
40.673091, -73.956841

And one last piece, south Broolyn:
40.680121, -74.020355
40.702118, -74.000614
40.705632, -73.995465
40.708625, -73.975037
40.695872, -73.918389
40.656685, -73.953751
40.651606, -74.009884


I would like to convert the (lon, lat) coordinates to (x[m], y[m]), using a flattening at the center of manhattan.

The mean radius ((2a + b)/3) of the Earth is R = 6371009 m.
source: https://en.wikipedia.org/wiki/Earth_radius

This can be used to convert each (lon, lat) coordinate to
given mean_lon and mean_lat
	x = R * cos(mean_lat) * (lon - mean_lon)
	y = R * (lat - mean_lat)


Next, I'll define the blocks, and group buildings to them.


--------------
Day 6 - Jul 13
--------------

Idea: Blocks should store the buildings in descending height order, and when a block is partially shadowed by buildings already on the silhouette, only the buildings that are higher than a certain height will get investigated in that block.

To do list for week 2:
--OK-- 1. Define blocks
--OK-- 2. Group buildings into the blocks
3. Design the SQL database
4. Load data (buildings and blocks) into SQL database
5. Set up SQL querries for cycling through the buildings and blocks
6. Write drawing algorithm in Python, using the querries to the SQL database
7. Put the Sun's path on the drawing, given the day of the year
8. Get minimal number of points required to representat the finished silhouette
9. For each point on the Sun's path, determine whether it's covered.
10. Create plot of direct sunlight as a function of time.


Using the (x, y) coordinates (measured in meters) has the range:
x in [-5e3, 6e3]
y in [-1e4, 1.3e4]

I'll used square blocks, aligned with the x,y coordinate lines, for simplicity.

There is 53306 building(parts) in the filtered Manhattan data.
In the algorithm, drawing the silhouette, 
	1. I loop through all buildings in the first block
	2. After adding each building to the silhouette, loop through all blocks to check if how much they are shadowed.
I estimate that the typical number of shadow-checks (checking if a building or block is already covered), is [Number of buildings in block] + [Number of final buildings visible] * [Number of blocks]

Given that 
	# of buildings =approx= 1e5
	# of visible buildings (typically) =approx= 20
the optimal number of blocks is =approx= 70

the range of x and y have the lengths:
x_max - x_min = 1.1e4
y_max - y_min = 2.3e4

A block size of 1000 * 1000 will produce 253 blocks over the rectangular map area, but approximately 2/3 of this will be empty. This gives a total of approx 80 blocks, which sound just right.

The blocks will be defined by their 
 - four vertices
 - list of building ids
 - heighest building height in the block

Note: I need to make sure to fix the origin of the (x,y) map to the earlier choosen values:

>> R = 6371009
>> deg2rad = np.pi/180
>> mean_lat =  40.771803
>> mean_lon = -73.973351
>> cos_mean_lat = np.cos(mean_lat * deg2rad)
>> this_x = R * cos_mean_lat * (lon - mean_lon)* deg2rad
>> this_y = R * (lat - mean_lat)* deg2rad

I define the gridlines of the blocks by the following list of x and y values:
x_grid = [-5e3, -4e3]

I need a function that assigns the (x,y) coordinate to one of the blocks.


I learned that SQL cannot store arrays.
This means I need to store the nodes in a separate table, and link them to buildings in their own table, and not link the buildings to their nodes in the buildings table.

SQL tables:
Nodes: 
	id: int, 
	lon: float(10,10), 
	lat: floar(10,10), 
	building_id: varchar(25), 

Buildings: 
	id: int, 
	height: float(10,10), 
	block_id: int, 
	number_of_nodes: int, 
	first_node: int

Blocks: 
	id: varchar(25), 
	xmin: float(10,10), 
	xmax: float(10,10), 
	ymin: float(10,10), 
	ymax: float(10,10), 
	x_id: int,
	y_id: int,
	max_height: float(10,10)


I realized that if I want to use the automatic indexing of the SQL database, then I need to load the tables in the following order:
1. Blocks
2. Buildings
3. Nodes

But I need to do this in a nested loop, so that when I add a block to the Blocks table, I also add the buildings in that block to the Buildings table and note the index of the block. And as I do that, I also add the nodes as I add the buildings, and indicate the building id on the nodes' records.



--------------
Day 7 - Jul 14
--------------
To do list for today:
--OK-- 1. Design the SQL database
--OK-- 2. Load data (nodes, buildings and blocks) into SQL database
--OK-- 3. Set up SQL querries for cycling through the buildings and blocks
	--OK-- a. given the observer's coordinates (lon, lat):
		- get cartesian coordinates
		- get block id (x_id, y_id)
	--OK-- b. given block id:
		- plot all buildings on the map in that block

Further work:
4. Write drawing algorithm in Python, using the querries to the SQL database
5. Put the Sun's path on the drawing, given the day of the year
6. Get minimal number of points required to representat the finished silhouette
7. For each point on the Sun's path, determine whether it's covered.
8. Create plot of direct sunlight as a function of time.


SQL Database tables: 
	Blocks: Id, Name, Xmin, Xmax, Ymin, Ymax, X_id, Y_id, Max_height
	Buildings: Id, Name, Height, First_node_id, Number_of_nodes, Block_id
	Nodes: Id, X, Y, Order_in_building, Number_of_nodes_in_building, Building_id,
		   Block_id

Maybe I can get away with only loading Blocks and Nodes.
for each block:
	- calculate X_id, Y_id, ... and Max_height
	- and load
	- get block_id
	for each building:
		- use the building key as building id
		- calculate number of nodes
		for each node:
			- determine order
			- get z
			- get X, Y, ...
			- load

I loaded the following two tables:
    CREATE TABLE Blocks(\
        Id INT PRIMARY KEY AUTO_INCREMENT,\
        Xmin FLOAT(20,10),\
        Xmax FLOAT(20,10),\
        Ymin FLOAT(20,10),\
        Ymax FLOAT(20,10),\
        X_id INT,\
        Y_id INT,\
        Max_height FLOAT(20,10)\
    )
    CREATE TABLE Nodes(\
        Id INT PRIMARY KEY AUTO_INCREMENT,\
        X FLOAT(20,10),\
        Y FLOAT(20,10),\
        Z FLOAT(20,2),\
        Order_in_building INT,\
        Number_of_nodes_in_building INT,\
        Building_id INT,\
        Block_id INT\
    )

Now I have SQLload.ipynb, which 
	- extracts data from XML
	- calcuates cartesian coordinates
	- defines blocks as 1000*1000 squares
	- collects buildings into blocks
	- creates the Nodes and Blocks tables in Manhattan_buildings SQL database
	- loads the node and block data to them 
	(I decided that a Buildings table is not needed, since I can associate each node with each block)

The next steps will star with the SQL database, and treat it as source of data.

I store the radius of Earth, mean_lon and mean_lat for Manhattan in the Cities table:
	CREATE TABLE Cities(\
        Id INT PRIMARY KEY AUTO_INCREMENT,\
        Name VARCHAR(25),\
        Planet_radius FLOAT(20,10),\
        Mean_lon FLOAT(20,10),\
        Mean_lat FLOAT(20,10)\
    )
and the gridline data in the Grids table:
	CREATE TABLE Grids(\
        Id INT PRIMARY KEY AUTO_INCREMENT,\
        Xmin FLOAT(20,10),\
        Xmax FLOAT(20,10),\
        Xstep FLOAT(20,10),\
        Ymin FLOAT(20,10),\
        Ymax FLOAT(20,10),\
        Ystep FLOAT(20,10)\
    )



After playin with the SQL queries, and plotting all buildings in a block, it seem to me that the blocks are too large. 
Buildings have more nodes than the blocks (which have 4), and therefore it is optimal to have smaller number of buildings in a block. I choose 500*500 blocks for now.

This also seems to run slow. And even if I limit the queries to buildings taller than 100 meters. Despite the fact that there's only a few of those.

I think the reason is that calling the cur.execute() many times is slower than calling it once, and post-processing the result. Hopefully, if I do it the later way, it will be faster.


--------------
Day 8 - Jul 15
--------------
First, I am going to try whether processing the result of a single SQL query in python is faster than submitting many queries.

This worked.

Now, for today:
--OK-- 1. Write drawing algorithm in Python (phi, theta building points -> silhouette)
--OK-- 1a. Write the add-cliff-to-silhouette algorithm
2. Write queries and convert node x,y,z to phi, theta
3. Put the drawing and the queries together for a single block
4. Get the exact equation for the Sun's position (given lon, lat, time_of_year, ...)
5. Put the Sun's path on the drawing, given the day of the year

Further work:
- Make the Block_id of the Nodes table a key
- Put together a simple version of the web app, showing mock images
- Connect the python function with the web app.
- For each point on the Sun's path, determine whether it's covered.
- Create plot of direct sunlight as a function of time.


I'll have two new classes: 
	Silhouette: containing all data about the view of the buildings
	Cliff: a single point of a Silhouette instance

I need to treat buildings that are covering the North direction separately, since these wrap around on the phi in [-pi,pi] interval. First let's just ignore them, and not add them to the silhouette.

Now, the Silhouette class (in DrawSilhouette.ipynb) implements:
	draw(): which draws the silhouette on the [-180:180]x[0:90] view
	add_roof(): which takes (phi1, phi2, theta) of a roof, and adds its silhouette to the Silhouette instance

Next, let's implement a function: 
	get_roof(x,y, building):
		given observers(x,y), and a Building instance
		returns (phi1, phi2, theta) coordinates

Instead of this, it is better to treat each way of the building as a separate roof piece.
Also, the observer also has a height, z.
Let's implement the function:
	draw_building(lon, lat, alt, building, silhouette):
		adds all roof pieces to the silhouette one after the other

This works, expect if the building is crossing the North-line.
Currently, the get_roof function orders phi1 and phi2. 
I need a way to indicate if a roof is south facing or north facing, in which case it crosses the North direction, and wraps around the phi in [-pi, pi] range.

Or, I can simply make two separate roof objects for every roof that lies on the North line.



--------------
Day 9 - Jul 16
--------------
For today:
--OK-- 1. Understand how the tutorian web app works
--OK-- 2. Modify it to show a plot
--OK-- 3. Link drawing functions to the web app's callback(s)
--OK-- 4. Make a webapp:
	--OK-- input: ["lon, lat"], z of observer
	--OK-- output: 
		--OK-- plot of the block's layout 
		--OK-- drawing of the silhouette

First, let's look at the tutoriall web app.

Directory structure:
webapp/
	app/
		static/
			css/
				bootstrap.css
				bootstrap.css.map
				bootstrap.min.css
				bootstrap-theme.css
				bootstrap-theme.css.map
				bootstrap-theme.min.css
			fonts/
				...
			js/
				bootstrap.js
				bootstrap.min.js
		templates/
			index.html
			cities.html
			input.html
			output.html
			starter-template.css
		a_Model.py (and .pyc)
		__init__.py (and .pyc)
		views.py (and .pyc)
	tmp/
		(empty)
	run.py

I conjecture that
1. the entire static/ directory needs to be present
2. the htmls in the templates/ directory needs to be modified to give a different content to the front-end
3. __init__.py and views.py areessential (and may or may not need to be changed)
4. a_Model.py is probably called by either run.py or views.py, and can be exchanged for anything
5. run.py is essential, and probably shoulnd't be changed


Next, let's investigate the content of different files:

run.py
======
It is very short:
"""
#!/usr/bin/env python
from app import app
app.run(debug = True)
"""
I looks like it imports everything in the app/ directory, and runs it (whatever that means) in debug mode (which I'm guessing makes it display error messages in the browser window)

Also, I remember that this is the file that needs to be run from the terminal, before the browser can connect to the local server, and display the web app. I'll not change run.py.

I created app/, tmp/ and run.py (with the content above) in my Project/WebApp/ directory.

I also copy the entire static/ directory and its content to app/


__init__.py
===========
It is very short:
"""
from flask import Flask
app = Flask(__name__)
from app import views
"""
It looks like this is the __init__ function (or process?) of the app package (or calss?).
It imports Flask, which is the workhorse here, and the creats a Flask instance, app, and imports everything in the views.py.
I'll not change __init__.py, and copy it to WebApp/app/


views.py
========
This is a quite long python file, with the preambule:
"""
from flask import render_template, request
from app import app
import pymysql as mdb
from a_Model import ModelIt
"""
Which imports flask and the app, which are probably obviously needed. Then it import SQL handling package, and the model a_Model

After this it open a connection to the database
"""
db= mdb.connect(user="root", host="localhost", passwd="123", db="world_innodb", charset='utf8')
"""

And the rest is structured as mappings of the "views", which are the strings written after 
http://localhost:5000
(including the starting '/')

e.g. 
"""
@app.route("/db_fancy")
def cities_page_fancy():
    with db:
        cur = db.cursor()
        cur.execute("SELECT Name, CountryCode, Population FROM City ORDER BY Population LIMIT 15;")

        query_results = cur.fetchall()
    cities = []
    for result in query_results:
        cities.append(dict(name=result[0], country=result[1], population=result[2]))
    return render_template('cities.html', cities=cities) 

"""
which defines a python function cities_page_fancy(),
which 
	- does some manipulation ot the database
	- gathers data into the list cities
	- passes the list to render_template() and returns its ouput (which is probably the page)
	- the first argument of render_template() is a string to an html file in app/templates/ (which probably contains the content information about the page)
This is the example, where no interactive elements are present, the SQL query is hard coded. This is probably not needed for the interactive app to work, and so does not the 'cities.html'.


another two examples are
"""
@app.route('/input')
def cities_input():
  return render_template("input.html")
"""
which simply defines the function that return the output of the rendering of "input.html" template

and
"""
@app.route('/output')
def cities_output():
  city = request.args.get('ID')

  with db:
    cur = db.cursor()
    #just select the city from the world_innodb that the user inputs
    cur.execute("SELECT Name, CountryCode,  Population FROM City WHERE Name='%s';" % city)
    query_results = cur.fetchall()

  cities = []
  for result in query_results:
    cities.append(dict(name=result[0], country=result[1], population=result[2]))

  #call a function from a_Model package. note we are only pulling one result in the query
  pop_input = cities[0]['population']
  the_result = ModelIt(city, pop_input)
  return render_template("output.html", cities = cities, the_result = the_result)
"""
which seem to do much more:
	- gets input with the line:
		" city = request.args.get('ID') "
		which is not a db operation. 
		And request is probably an object defined outide cities_output()
	- queries the SQL database with the input just fetched, and fethes the result
	- creates the list of outputs from the query result to a list of dicts
	- gets the first output (just to show and example), and feeds it in ModelIt (a function of a_Model)
	- with the return of that, it calls the rendering, using now the "output.html" as template, and additional arguments defined by the 'name=value' convention

This function seems to be the "main" function of a single usage of the web app. I copied view.py to WebApp/app/ and kept only two view mappings: '/input', and '/output', but didn't modify them yet.


a_Model.py
==========
This is a simple example:
"""
def ModelIt(fromUser  = 'Default', population = 0):
  print 'The population is %i' % population
  result = population/1000000.0
  if fromUser != 'Default':
    return result
  else:
    return 'check your input'
"""
which defines a function that is run in the output() function under the @app.route('/output') mapping in view.py. It returns a single number, so it seems to me that this can be any function I need to happen inside output().

I'll write my own function to do this, so I don't need a_Model.py. (unless I call it specifically in output() of views.py)

In the templates/ directory, I'm guessing I'll only need the templates which are actually referred to in the first argument of the render_template() function. This means I only need 'input.html' and 'output.html'. I'll copy those, and the starter-template.css too, just in case.

Let's copy a_Model.py to app/ too, and test if the app works, now that I stripped a few things off it, and it's at a different location.

It worked.



Now, let's take a look at the template files:

input.html
==========
This is an html file.

In the head, I can change the title of the page. But otherwise, I think I'm going to leave it alone.

In theb body, there's a <nav> part:
"""
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Project name</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li class="active"><a href="#">Home</a></li>
            <li><a href="#about">About</a></li>
            <li><a href="#contact">Contact</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </nav>
"""
where I change 'Project name' to 'SunnyMinutes', and leave the rest alone. (Probably later, we will add content to this, or to the bookmarks it refers to.)

Further down in the body, it says
"""
  <div class="container">

	...
	...
	...
  </div> <!-- /.container-->

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
    <script src="../../dist/js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../../assets/js/ie10-viewport-bug-workaround.js"></script>
"""

The first part seems to contain everything that's actually on the page, under the header bar.
The second part says "... core JavaScript", which I'm afraid of, so I'm not going to touch it.

So, it seems the real content of the page is:
"""
<div class="container">

    <div class="starter-template">
        <h2>Input Page</h2>
        <p>Enter some user input</p>
    </div>

    <div class = "container">

      <form  action="/output" method="GET">
        <div class="form-group">
          <label for="ID">City  Name:</label>
          <input type="text" id="ID" name='ID' placeholder="e.g. ">
        </div>

        <div>
          <button type="submit" class="btn btn-default btn-lg">Find this city!</button>
        </div>

      </form>
    </div>

    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="static/js/bootstrap.min.js"></script>

  </div> <!-- /.container-->
"""

This seems to be doing the followin:
	1. Writes the text "Input Page" and "Enter some user input" to the page with different styles
	2. Puts up a form with <form action=... > ... </form>
		which defines the action to be '/output' (which I'm guessing gets the '/ouput' view)
		and also specifies the components:
			- a form with label and input
			- a submit button
	3. two lines calling javascript, which I'll leave alone.



output.html
===========
This is a modified version of input.html. 
The beginning is the same.
The added part is:
"""
</div> <!-- /.container-->

    <div class="container">
      <div class="starter-template">
        <h3>Results:</h3>
        <p class="lead">Below is the result of your query.<br> You just took user input and looked up the information. Now we need to expand the functionality!</p>
      </div>

      <table class="table table-hover">
      <tr><th>Name</th><th>Country</th><th>Population</th></tr>
      {% for city in cities %}
      <tr><td>{{ city['name'] }}</td><td>{{ city['country']}}</td><td> {{ city['population'] }}</td></tr>
      {% endfor %}
      </table>


     </div><!-- /.container -->

    <div class="container">
      <div class="starter-template">
        <h3>Another Result:</h3>
        <p class="lead">Now we've taken the input and called a function from your package.<br>The result is {{the_result}}</p>
      </div>


      <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>
      <script src="static/js/bootstrap.min.js"></script>


     </div><!-- /.container -->
"""
which
	1. writes text
	"""
	  <div class="starter-template">
        <h3>Results:</h3>
        <p class="lead">Below is the result of your query.<br> You just took user input and looked up the information. Now we need to expand the functionality!</p>
      </div>
	"""
	
	2. puts up a table with a for loop
	"""
	<table class="table table-hover">
		<tr><th>Name</th><th>Country</th><th>Population</th></tr>
		{% for city in cities %}
			<tr><td>{{ city['name'] }}</td><td>{{ city['country']}}</td><td> {{ city['population'] }}</td></tr>
		{% endfor %}
	</table>
	"""
	where citis is an argument of the render_template function

	3. Put some more text, using input {{the_result}}
	"""
	<div class="starter-template">
        <h3>Another Result:</h3>
        <p class="lead">Now we've taken the input and called a function from your package.<br>The result is {{the_result}}</p>
      </div>
	"""


The way I understand it, it I only need a single template 'output.html'.

But than without the inputs that output.html displays it crashes.

So, first, let's compile the input.html.
Then, create a copy of it, and add the part that show up only after the inputs are processed.


Let's put a random dynamic plot to the input page.
I'll use the recipe, foud here: 
http://stackoverflow.com/questions/20435604/flask-matplotlib-graphics-in-template

This worked, expect the image was simply added with the line
"""
<img src="./mypng">
"""
where mypng is the route's name in views.py


I think it will be great to store the query data and the already generated silhouettes in the SQL database.

I got the block plotting function to work nicely. Under the route mapping name '/block_map'.

Next, let's see how fast (and well) does the silhouette drawing algorithm run.
In /DrawSilhouette/Block_Silhouette.ipynb, I implemented this, and seems to run quite fast.


Things to do before the demo is ready:
--OK-- 1. Plot the Sun's path on the silhouette
2. Display silhouette on web app for the given day
--OK-- 3. Calculate percentage of sunlight for the given day
4. Extend the plotting range to 9 blocks around the observer

---------------
Day 10 - Jul 17
---------------

Things to do:
--OK-- 1. Add silhouette plotting capability to web app.
--OK-- 2. Prepare slides.
--OK-- 3. Extend web apps capabilities:
	--OK-- - investigate blocks around the selected block
	--OK-- - plot only the buildings on the block map which are higher than the observer


Further work:
1. Add plot about the Sun's power over day



---------------
Day 11 - Jul 18
---------------
SunnyMinutes app now works.
Inputs:
	- Address as "<<lat>>, <<lon>>"
	- floor number
	- day of the year as "month/day"
Outputs:
	- plot of the 9 closest blocks around the observer
	- plot of the cities skyline seen by the observer with the sun's path on it
	- put a text " # min sunny / # min total" on the plot

Further work to be done:
 - Make it pretty
 - Make it show a polar plot of the skyline and sun's path
 - Consolidate code
 - Get the Address field take real address strings and output geocoordiantes using google's API
 - embed google maps
 - get the google maps window return a coordinate to the location field upon clicking on it
 - get scores for morning/ midday/ afternoon light
 - get scores for sunrise and sunset


Ideas I got from feedbacks from Friday:
 - add the selling point of installing solar panels outside the windows
 - add health related packaging: 
 	+ required amount of light to avoid depression
 	+ relationship between sunlight exposure and mental health
 - estimate if the sun is going to be blocked by clouds
 - add some kind of validation
 - explain the Node and Building objects with drawing
 - explain algorithm of drawing the silhouette better
 - use mechanical turk to gather data on how well people can guess the sunny minutes

To do list for today:
	--OK-- 1. get a list of functions and classes
	--OK-- 2. create individual package files
	--OK-- 3. create functions to run in views.py (make it look like a main() )
	--OK-- 3a. add ORDER BY statement to SQL queries
	4. figure out how google's API works
	5. implement address -> goecoordinates function with google's API
	--OK-- 6. create polar plot
	--OK-- 7. display sunny/total minutes as text
	8. display winter/summer solstice and sprin/fall equinox sunny minutes values

Further work:
	- add capability to investigate all blocks in the database using their coordinates and max height
	- embed google maps, centered on the search point
	- figure out how to get geocoordinate from a click on the embedded map
	- feed the geocoordinates to calculation
	- dispay morning/midday/afternoon sun scores



List of classes (and their functions):
	Node: show()
	Building: show(), plot_footprint(), calculate_center()
	Block: calculate_max_z(), plot_on_map()
	Roof: show()
	Cliff: show()
	Silhouette: draw(), add_roof()
	Sun_path: get_date(), calcualte_path(), calculate_visibility(), draw()


List of standalone functions:
	is_outside(boundary_node_1, boundary_node_2, building_node)
	assign_to_block(building_id, building, x_grid, y_grid, blocks)
	get_GPS_from_address(address, lon, lat)
	convert_to_cartesian(lon, lat, mean_lon, mean_lat, Earth_radius)
	find_my_block(x_my, y_my, x_grid, y_grid)
	get_roofs(obs_x, obs_y, obs_z, building, blur_epsilon)
	get_city_vectors(lat, lon, greenwich_time_minutes)
	get_sun_vector(date)
	(and the rendering functions for each route in views.py)


I'll
	OK - leave my_classes.py intact
	OK - put Node, Building, Block into one file, and
	OK - put Roof, Cliff, Silhouette into another, and
	OK - put Sun_path will be in a third
	!no!- make a new class for grids
	OK - add assign_to_block to Building class
	OK - add get_roofs to Building class
	OK - add get_city_vectors and get_sun_vector to Sun_path class
	OK - add is_outside to the Node class

	functions not in classes:
		get_GPS_from_address(address, lon, lat)
		convert_to_cartesian(lon, lat, mean_lon, mean_lat, Earth_radius)
		find_my_block(x_my, y_my, x_grid, y_grid)
		
