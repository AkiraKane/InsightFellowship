Diary of SunLight project development
=====================================

--------------
Day 1 - Jul 07
--------------

I wanted to use Google maps data to predict the time of sunlight in different apartments near highrises.

--------------
Day 2 - Jul 08
--------------

Google doesn't share height data of buildings, only ground elevation.
[https://developers.google.com/maps/documentation/elevation/]

I found OpenStreetMap data, which has building height data.
[http://wiki.openstreetmap.org/wiki/Main_Page]

Manhattan is fully char

Andrew suggested a health oriented selling point. People who need sunlight due to psychological reasons can check how much sunlight they will get in their apartment/office throughout the day and year before even visiting the place.

I found the Overpass API
[http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide]

--------------
Day 3 - Jul 09
--------------

I found a working call to Overpass API, that downloads an XML.
[http://inasafe.org/en/developer-docs/osm_building_downloads.html]
>>> http://overpass-api.de/api/interpreter?data=(node["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725);way["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725);relation["building"="yes"](-6.185440796831979,106.82374835014343,-6.178966266481431,106.83127999305725););(._;>;);out body;

I found a simple way to debug the Overpass API calls through Overpass's interactive web app.
[http://overpass-turbo.eu/]

I realized, I need only the "way" objects.

I realized that I need to extend from '["building" = "yes"]'' to simply '["building"]' in the query, since some buildings are e.g. "building" = "church" etc.

I used Google Maps to find an approximate bounding box for Manhattan.
s = 40.685816
w = -74.037724
n = 40.881304
e = -73.902455

I synthetsized the above into the following Overpass API query:
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.685816,-74.037724,40.881304,-73.902455););(._;>;);out body;


Using the above query I downloaded the XML data to 
~/InsightFellowship/Project/Manhattan_buildings.xml

I decidede to use beautifulsoup to parse the XML file. But I don't know in which format should I store the data to make it easy to analyze for light-ray-crossing.


In order to efficiently determine the siluettes of the buildings from the observer's position I'll do the following:
 a. Group the buildings into larger rectangular blocks (N_blocks := sqrt(N_buildings))
 b. For each block calculate and store:
 	i. max height
 	ii. 2D coordinates of the 4 vertices of the block
 c. When rendering the siluette:
 	0. Exlude all blocks with max height smaller than observer's altitude
 	1. Start with self
 	2. Continue with the buildings in the same block
 	3. Continue with the buildings in the neighboring blocks
 	4. Continue with all remaining buildings
 	5. After each a building's siluette is added to the view, exclude blocks that are completely shadowed by the new siluette

I think the above algorithm will allow a fast and complete generation of the siluette view. After which calculating when is the Sun blocked is probably simple.

Given the blocks (4 vertices: x1,y1,x2,y2,x3,y3,x4,y4, and max height z_max), the following pseudocode will (hopefully) do the job:

draw_siluette(buildings, blocks, obs):
	% buildings is an array of building instances:
	%	Key: id
	%	- vertices: array of tuples(x,y)
	%	- height: z
	%	- block id

	% blocks is dict of block instances:
	%	Key: id
	%	- list_of_buildings: array of building id's
	%	- max height, z_max
	%	- vertices: array of length 4 of tuples(x,y)
	% 	- center

	% obs is the observer's position: tuple(x,y,z)

	% siluette is an array of arrays of tuples(phi, theta), ordered by distance from observer, defining the rooflines of the buildings with visible roofline

	siluette = []
	
	block_order = []
	for block in blocks:
		% get blocks which are higher than the observer
		if block.z_max > obs.z:
			% find distances to each block center
			block_order.append( tuple( id, distance(block.center, obs) ) )
	% determine the order in which the blocks should be investigated
	block_order.sort(by second element of the tuple)

	while len(block_order):
		block_id = block_order[0][0]
		% get buildings from the block shorter than the observer
		building_order = []
		for building_id in blocks[block_id.list_of_buildings
			if building.z > obs.z:
				building_order.append(building_id)

		% draw buidlings on siluette
		for building_id in building_order:
			building = buildings(building_id)
			% calculate observing angles for each vertex
			observed_vetices = []
			for vertex in building.vertices:
				tuple = get_phi_theta(vertex, building.z,  obs)
				observed_vertices.append(tuple)				
			siluette.append(observed_vertices)

		% remove the processed block from the list
		block_order.pop(0)

		% evaluate whether the remaining blocks are shadowed
		for remaining_block in block_order:
			block_id = remaining_block[0]
			if is_block_shadowed(block(block_id), siluette):
				block_order.remove(remaining_block)

	% at this point siluette is an array of arrays of tuples(phi, theta), each corresponding to the arrays of the vertices of each buildings from visible blocks

	% let's get rid of totally blocked buildings


		
For the slides for Friday, I decided to plot the histogram of the heights. This seems the easiest, since I need to extract only the height information from the XML file, which is always at '<tag k="height" v="19.6"/>'.

After plotting the histogram, I realized that the landmark buildings are missing their heights. This is because their height is a tag to ways with "building:part" tags.

I tried the following two calls
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.751194, -73.976618, 40.752031, -73.974204););(._;>;);out body;
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.748134, -73.986997, 40.749085, -73.984336););(._;>;);out body;

And tried
"
way["building"](40.748134, -73.986997, 40.749085, -73.984336);
way["building:part"](40.748134, -73.986997, 40.749085, -73.984336);
/*added by auto repair*/
(._;>;);
/*end of auto repair*/
out body;
"
in 
http://overpass-turbo.eu/

This resulted in the full structure data of the Empire State Building. 

So I changed the Overpass API call to
>>> http://overpass-api.de/api/interpreter?data=(way["building"](40.685816,-74.037724,40.881304,-73.902455);way["building:part"](40.685816,-74.037724,40.881304,-73.902455););(._;>;);out body;

Empire State Building:
http://overpass-api.de/api/interpreter?data=(way["building"](40.748134, -73.986997, 40.749085, -73.984336);way["building:part"](40.748134, -73.986997, 40.749085, -73.984336););(._;>;);out body;


--------------
Day 4 - Jul 10
--------------

In the morning I put together the slides, "3Slides.pdf" for the afternoon presentation.

Before starting crunching the data, I need to parse the XML into a structure I can use.
XML contains the following type of lines:
Header lines:
	<?xml version="1.0" encoding="UTF-8"?>
	<osm version="0.6" generator="Overpass API">
	<note>The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.</note>
	<meta osm_base="2015-07-10T01:22:02Z"/>

Node list:
  	<node id="530737132" lat="40.7514887" lon="-73.9758501"/>
	  OR
    <node id="2666720512" lat="40.7522067" lon="-73.9741698">
	<tag k="entrance" v="main"/>
	</node>

Way definitions:
	<way id="42500770">
	    <nd ref="530737132"/>
	    <nd ref="2665014478"/>
	    <nd ref="2665014638"/>
	    <nd ref="530737135"/>
	    <nd ref="530737137"/>
	    <nd ref="2665014479"/>
	    <nd ref="2665014429"/>
	    <nd ref="2714805423"/>
	    <nd ref="2665014352"/>
	    <nd ref="2665014344"/>
	    <nd ref="2665014314"/>
	    <nd ref="2665014313"/>
	    <nd ref="2714805412"/>
	    <nd ref="530737139"/>
	    <nd ref="530737132"/>
	    <tag k="building" v="tower"/>
	    <tag k="building:part" v="no"/>
	    <tag k="building:use" v="office"/>
	    <tag k="name" v="Chrysler Building"/>
	    <tag k="name:el" v="Κτίριο Κράισλερ"/>
	    <tag k="name:es" v="Edificio Chrysler"/>
	    <tag k="name:he" v="בניין קרייזלר"/>
	    <tag k="name:ru" v="Крайслер-билдинг"/>
	    <tag k="start_date" v="1930"/>
	    <tag k="tourism" v="yes"/>
	    <tag k="wikipedia" v="en:Chrysler Building"/>
  	</way>
  		OR
  	<way id="159899676">
	    <nd ref="1719705334"/>
	    <nd ref="1719705331"/>
	    <nd ref="1719705315"/>
	    <nd ref="1719705327"/>
	    <nd ref="1719705334"/>
	    <tag k="building" v="yes"/>
	    <tag k="building:colour" v="#818880"/>
	    <tag k="building:part" v="yes"/>
	    <tag k="height" v="22"/>
	    <tag k="name" v="Socony-Mobil Building"/>
	    <tag k="nycdoitt:bin" v="1036153"/>
	    <tag k="roof:material" v="concrete"/>
	    <tag k="roof:shape" v="flat"/>
	    <tag k="start_date" v="1956"/>
  	</way>

Footer:
	</osm>

In 'Crysler.xml', I have a small dataset, containing the entire Crysler buidling, which I'll use to debug my code.

Tasks for today:
1. Load list of nodes and ways into pandas dataframes
2. Create a new dataframe, containing building data
3. Save the building dataframe to disk
4. Determine good coordinates to define the blocks
5. Create the blocks in a new dataframe
6. Save the blocks dataframe to the disk


Here's a piece of Python code to check which packages are installed:
>>> import pip
>>> installed_packages = pip.get_installed_distributions()
>>> installed_packages_list = sorted(["%s==%s" % (i.key, i.version)
     for i in installed_packages])
>>> print(installed_packages_list)


--------------
Day 5 - Jul 12
--------------

Tasks for today:
--OK-- 1. Load list of nodes and ways into dicts
--OK-- 2. Create a new dict, containing building data
3. Save the building data to disk
4. Determine good coordinates to define the blocks
5. Create the blocks in a new dict
6. Save the blocks dict to the disk


I defined the center attribute to the Building class, and this way I created a scatter plot of all buildings in the dataset. Since the bounding box for the Overpass API was a rectangle, many more buidlings are included, other than the ones in Manhattan.

I need a way to select the buildings in Manhattan.

Let's list the coordinates of Mahnattan's (approximate boundary).
40.686467, -74.034462
40.700003, -74.025536
40.756201, -74.013176
40.826122, -73.964768
40.881953, -73.933525
40.871569, -73.909150
40.856900, -73.919707
40.845149, -73.928547
40.835733, -73.933096
40.807869, -73.931637
40.790975, -73.910523
40.777198, -73.928032
40.779278, -73.934813
40.773623, -73.939190
40.768488, -73.939791
40.739945, -73.966399
40.709633, -73.971978
40.703842, -73.998328
40.680804, -74.021073

I need an algorithm to drop to buildings that our outside this boundary.

I can do this if the boundary is convex. Let's define a convex boundary:
40.875615, -73.904533
40.791452, -73.907966
40.706402, -73.967017
40.676465, -74.020233
40.682193, -74.035339
40.757133, -74.015083
40.884441, -73.932342

This worked okay. I can refine the results by defining the convex boundaries of the neighboring regions:
Bronx:
40.871332, -73.909511
40.894563, -73.880328
40.852377, -73.811836
40.803538, -73.822307
40.795871, -73.911914
40.802563, -73.927836
40.809515, -73.933501
40.824422, -73.933415
40.835203, -73.933973
40.847118, -73.927364
40.861531, -73.916334

This worked nicely. Now, let's do the same for Brooklyn:
40.708105, -73.974007
40.744920, -73.961819
40.755974, -73.952034
40.778206, -73.931606
40.791463, -73.910149
40.801340, -73.885430
40.752983, -73.788269
40.653038, -73.900192
40.673091, -73.956841

And one last piece, south Broolyn:
40.680121, -74.020355
40.702118, -74.000614
40.705632, -73.995465
40.708625, -73.975037
40.695872, -73.918389
40.656685, -73.953751
40.651606, -74.009884


I would like to convert the (lon, lat) coordinates to (x[m], y[m]), using a flattening at the center of manhattan.

The mean radius ((2a + b)/3) of the Earth is R = 6371009 m.
source: https://en.wikipedia.org/wiki/Earth_radius

This can be used to convert each (lon, lat) coordinate to
given mean_lon and mean_lat
	x = R * cos(mean_lat) * (lon - mean_lon)
	y = R * (lat - mean_lat)


Next, I'll define the blocks, and group buildings to them.


--------------
Day 6 - Jul 13
--------------

Idea: Blocks should store the buildings in descending height order, and when a block is partially shadowed by buildings already on the silhouette, only the buildings that are higher than a certain height will get investigated in that block.

To do list for week 2:
--OK-- 1. Define blocks
--OK-- 2. Group buildings into the blocks
3. Design the SQL database
4. Load data (buildings and blocks) into SQL database
5. Set up SQL querries for cycling through the buildings and blocks
6. Write drawing algorithm in Python, using the querries to the SQL database
7. Put the Sun's path on the drawing, given the day of the year
8. Get minimal number of points required to representat the finished silhouette
9. For each point on the Sun's path, determine whether it's covered.
10. Create plot of direct sunlight as a function of time.


Using the (x, y) coordinates (measured in meters) has the range:
x in [-5e3, 6e3]
y in [-1e4, 1.3e4]

I'll used square blocks, aligned with the x,y coordinate lines, for simplicity.

There is 53306 building(parts) in the filtered Manhattan data.
In the algorithm, drawing the silhouette, 
	1. I loop through all buildings in the first block
	2. After adding each building to the silhouette, loop through all blocks to check if how much they are shadowed.
I estimate that the typical number of shadow-checks (checking if a building or block is already covered), is [Number of buildings in block] + [Number of final buildings visible] * [Number of blocks]

Given that 
	# of buildings =approx= 1e5
	# of visible buildings (typically) =approx= 20
the optimal number of blocks is =approx= 70

the range of x and y have the lengths:
x_max - x_min = 1.1e4
y_max - y_min = 2.3e4

A block size of 1000 * 1000 will produce 253 blocks over the rectangular map area, but approximately 2/3 of this will be empty. This gives a total of approx 80 blocks, which sound just right.

The blocks will be defined by their 
 - four vertices
 - list of building ids
 - heighest building height in the block

Note: I need to make sure to fix the origin of the (x,y) map to the earlier choosen values:

>> R = 6371009
>> deg2rad = np.pi/180
>> mean_lat =  40.771803
>> mean_lon = -73.973351
>> cos_mean_lat = np.cos(mean_lat * deg2rad)
>> this_x = R * cos_mean_lat * (lon - mean_lon)* deg2rad
>> this_y = R * (lat - mean_lat)* deg2rad

I define the gridlines of the blocks by the following list of x and y values:
x_grid = [-5e3, -4e3]

I need a function that assigns the (x,y) coordinate to one of the blocks.


I learned that SQL cannot store arrays.
This means I need to store the nodes in a separate table, and link them to buildings in their own table, and not link the buildings to their nodes in the buildings table.

SQL tables:
Nodes: id, lon, lat, building_id, next_node_id
Buildings: id, height, block_id, number_of_nodes, first_node
Blocks: id, xmin, xmax, ymin, ymax, block_id_N, block_id_S, block_id_E, block_id_W,
		max_height